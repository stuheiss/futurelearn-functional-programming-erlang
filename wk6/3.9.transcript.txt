0:03Skip to 0 minutes and 3 secondsJOE ARMSTRONG: In this talk I'm going to take a complete small concurrent program and do some refactorings on it. I'm going to break it into two parts. Of one of which contains all the concurrency primitives, the other contains none of them. So let's start with the program. This is a little counter program. This is about the simplest concurrent program you can write. It represents a counter. You can do two things to the counter. You can increment it, you can call a function, tick(N), it has a local State variable whose value, if we say tick(N), it will increase that State variable by the value of N, and we can read it, and it starts off with 0.

0:46Skip to 0 minutes and 46 secondsIt's a very simple thing. If we started it at 0, and said tick(5) and read it, we'll get back the answer 5. If we then said tick(10) and read it, we get back the answer, 15. So it doesn't do anything complicated at all. And it's intentionally simple, so that we can concentrate on the details of how it's been built. So it's put into one module. The module is called counter0. That module exports a start function, a tick function, and a read function, and also a loop function.

1:20Skip to 1 minute and 20 seconds The loop function is not-- it's really there for technical reasons because when you spawn a function, if you use this spawn module function arguments syntax you have to export the function which is being spawned, and that's why loop is being exported from the module. So to start the function, we use the register primitive, so register(counter0, spawn(counter0, loop, [0])). And that makes a global process called counter0, and it's running this function loop, whose initial argument is 0. So if you look at the State, the value of State in the beginning is 0. Now, to tick it, we do a remote procedure called tick(N).

1:59Skip to 1 minute and 59 seconds And that was the same remote procedure call that I showed you a couple of lectures ago, so I won't talk about that again. The tick message gets received. It sends back an ack message, an acknowledgment, and, in the case of a read, it sends back the value of the State variable in the loop. And then it recurses with either State + N, if you sent it a tick(N) message, or it recurses with loop(State) if you sent it a read message because the state doesn't change if you merely read it. So that is just about the simplest concurrent program it's possible to write that actually does anything that's vaguely useful.

2:38Skip to 2 minutes and 38 secondsSo what I'm going to do now is factor it into two parts. I haven't changed the rpc function. I'll leave that alone. But what I have done is move some of the code into a separate module; the module that's called counter0, the bulk of that code is now in a module called gen_server_lite, it now exports a start function with two arguments. loop is exported for the same reason as before, and I've put the remote procedure call into the gen_server_lite module. OK, so what does start(Mod, State) do? It registers now, Mod. If you looked at the last program, register was frozen, the frozen value, counter0. In this case, it becomes a variable.

3:23Skip to 3 minutes and 23 secondsIn this program, Mod is not an argument to start with. In the next program here, the module is the first argument to the start function. So we create a registered process, a global process, called Mod, and it's created by spawning gen_server_lite, loop, [Mod,State]. And if you compare that to the last program state, loop had one argument which is State, and now it's got two arguments, Mod and State. And that second argument, Mod, is passed through all the calls to loop.

3:54Skip to 3 minutes and 54 seconds Now, there's only one pattern in the receive part of the code, and that says that, OK, so if we get {From, Tag, Query} it's to evaluate Mod:handle(Query, State) So when we start that, the value of Mod is actually going to be counter1, OK.

4:18Skip to 4 minutes and 18 secondsSo it's actually at the point where it says Mod:handle(Query,

4:20Skip to 4 minutes and 20 secondsState) it's going to call counter1:handle(Query, State) That's a function of two arguments that takes the message that the client has sent to it and the initial state, and it returns two values in the tuple. The first is something that's got to go back to the client, and the second is this thing you have to recurse with.

4:40Skip to 4 minutes and 40 secondsAnd so the return value from Mod:handle(Query, State) is this tuple {Reply, State1} Reply goes back to the client, State1 becomes the argument of loop for the next recursion. OK, what about the code that calls it, counter1? Well, to start, first I import from gen_server_lite start and rpc, that's all I need to do. And then I say, well, start is start(counter1, 0) so it calls gen_server_lite (Mod, State) with the value of Mod being counter1. And then tick and N just become two remote procedure calls. And then I have to supply this handled routine that has two arguments-- the message that is being sent. In this case, tick(N) or read-- and the state, and it returns a tuple with two values.

5:28Skip to 5 minutes and 28 seconds One of the values is to go back to the client, the other is for the recursion. OK, so I've done that refactoring. Now if you look at that refactoring, you'll notice something interesting about it. I split it into two modules. Now one of the modules has the primitives, register, spawn, send, receive. These are all the concurrency primitives. The second module, counter1 has none of them. So what I've managed to do is split a single program that has concurrency constructs into two modules. One of which has all the concurrency parts, the second one has no concurrency parts at all. And that's good programming practise because concurrent programming is actually rather difficult, and it's perceived as difficult.

6:05Skip to 6 minutes and 5 seconds And, in many cases, we don't need to write totally concurrent programs, we need to use concurrent frameworks. So we can take something like a server, and turn it into two parts, one of which is generic and has the concurrency primitives in, the other of which is well typed sequential code, OK. So I think this is the road to the generic servers that live in the OTP system. We can do a lot more than these simple transformations. Both sides of this code can be developed separately. So we can have one group of people who take this gen_server_lite thing and improve it. They make a much more complicated one, and that becomes the gen_server in the OTP libraries.

6:51Skip to 6 minutes and 51 seconds And Francesco is going to tell you more about that in his lectures. The second one can concentrate on the client side of things, and they don't really need to know how the gen_servers work, they just need to use them. So we can separate the division of labour when we're building systems. It turns out that you don't actually need a very large number of generic things, but you do need a large number of plugins. So I've been involved in some very big projects where we've had 60 or 70 programmers, and the vast majority of them have been writing generic servers, and things like that, with very few people concentrating on the generic parts, which can be used and reused by everybody.

7:30Skip to 7 minutes and 30 seconds OK, so to summarise, we saw earlier that Erlang has four primitives for concurrency, spawn, send, receive, and self. It's got a mechanism for timeouts. It's got register and whereis. And it's got mechanisms for trapping errors. And we saw how to build our own concurrency abstractions, but we didn't see how we put the parts together. This example shows how we put the parts together, and, by extension, it shows how we build libraries and frameworks that are useful for building a much larger system. And Erlang has been used using these frameworks for building very large and very successful commercial real time systems.
