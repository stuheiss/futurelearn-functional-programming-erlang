0:03Skip to 0 minutes and 3 secondsJOE ARMSTRONG: In the internet, we have DNS, the Domain Name System, that converts symbolic names into addresses. Clients go to DNS. They convert names into addresses. And then the clients go and connect to these servers and request services. So it's actually the model that's controlling a large proportion of the internet. I'm going to do this in pure Erlang. I'm not going to use sockets and things like that. And I'm going to do it as simply as possible using what you might call textbook Erlang. So let's look at the overall structure of the domain name system. The domain name system is just a simple mechanism for turning names into addresses. So for example, if we say whereis www.erlang.

0:39Skip to 0 minutes and 39 secondsorg, we ask a name server, and it will return an address. It's actually not 234.56.78. It's something completely different. This is just an illustration. And it uses this thing called DNS, the Domain Name System. DNS is made reliable by having several replicated copies of the same information. So your computer will actually have several DNS servers that it knows about. It will ask the first one whereis erlang.org. And if it doesn't get a reply from the first one, or if the first server is broken, then it will ask the second one. And this is a very reliable way of doing things. The chances that all the DNS servers are broken at the same time is very small.

1:33Skip to 1 minute and 33 secondsSo DNS is a name server. It converts names to addresses, and it's replicated. That is actually quite difficult to do, so I'm not going to talk about how it's replicated or how that is done. It's hiding a lot of complex things that you don't really want to know about. And it's accessed through a bit of software called a resolver. So the servers, when they provide a service, have to register their name with DNS. And a client that wants to do something has to go to DNS, find the name of where the server is-- in this case, it's an IP address-- and then they access the server and get information they want. I want to mirror all of that in Erlang.

2:15Skip to 2 minutes and 15 seconds So one of the ways we use a lot to explain how this works is to use message sequence diagrams. So here's a message sequence diagram. And time flows downwards on the diagram, and messages flow horizontally on the diagram. So here, three processes are involved-- a client process, an expression server process, and a name server. And at the start of the world, the expression server will go to the name server and register its name with the name server. So if we want to use this expression evaluator-- I have called it a service whose name is calc, and I've said, well, it might be available on a certain IP address.

2:57Skip to 2 minutes and 57 seconds I would send a message to the name server telling it to register the thing. That's the first red message that you see to the top right-hand side of the diagram. And the name server might acknowledge that. Somebody wants to use that. A client will go to the name server and say, OK, so where's this calc service. And the name server will respond, hopefully, with the address of where the service can be found. And then having done that, it can send a message to the expression server saying, hey, please evaluate this expression for me. In this slide it says, OK, so could you evaluate 2 plus 3 for me? Yes. The answer is 5.

3:31Skip to 3 minutes and 31 seconds So what I want to do is build the simplest possible model of this in Erlang. And I don't want to talk about reality. Reality makes the problem more tricky. But they're kind of technical details. Let's just look at the essential algorithm. And then later, we can talk about reality-- how we cache things, how we replicate things. But I don't want to detract from the essential simplicity of the problem. So this is actually all you need. The name server part and the resolver part are built into Erlang. These are primitives-- whereis and register. Register-- register is a name, so it plays the role of DNS. Where is plays the role of a resolver. So here I put everything into one module.

4:24Skip to 4 minutes and 24 seconds And there's a reason for that, which I will explain in a moment. The module exports a number of functions. We put both the client and the server code in the same module. Just keep it simple. So the first function that you would start with is one that is executed by the server. It's this function start with zero arguments. And what does it do? It says spawn calc init. That spawns a parallel process. And then what init does is it registers itself. You see the second line of init says register calc with self. And that that is equivalent to going to DNS and registering your name. And then it goes into a loop.

5:01Skip to 5 minutes and 1 second The loop just waits for a message that says OK, go do something, and it does it. And what happens in that loop is when it gets a message from the client, it calls this expression evaluate, and it replies to the client. So that's the server side of things. The client side of things-- that's just a simple function, execute. It just sends a message to this registered process called calc. Because once you've registered the process name, you don't even need to look it up. You can just send a message to it directly, and it waits for a reply from that server.

5:35Skip to 5 minutes and 35 seconds The version of the remote procedure call that's been embedded in this code-- it's not the best way of doing things. This is not the best way of doing things. It's the simplest way to explain it. This just shows you, in pure Erlang, the essential simplicity of what we're doing. So what I've shown you is something that mirrors the DNS design, and it can be used to test all the logic of the server. We don't need to have a network. We don't need to have a distributed system in order to test this. We can test everything on a single laptop.

6:06Skip to 6 minutes and 6 seconds We can set up an emulation of hundreds or even thousands of internet nodes all communicating, and it will work in the same way. The only difference, when we deploy it in the cloud or in a large network of computers, is that things like latency will change. But the logic will not change. When we're in a single environment, testing it and debugging it, it's going to be a lot simpler. And this is how we develop large Erlang applications. So what we looked at in the first lecture were how we turned sequential code into parallel code.

6:40Skip to 6 minutes and 40 seconds And I showed you how there's about three, four, five, six little primitives you need to do, and you can take a sequential program, and you can turn it into a parallel program. And then I looked at how we could build the abstractions we need to build parallel programs using these simple parts. So we could define a remote procedure call, or we could do promise and yield, and we could build futures, and things like that. That's very valuable. That's very useful. And we can build whatever we want using these primitives.

