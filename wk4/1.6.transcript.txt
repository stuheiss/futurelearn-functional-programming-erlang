0:03Skip to 0 minutes and 3 secondsJOE ARMSTRONG: In this lecture I'm going to introduce concurrency. And I'm going to show you how we can start with a simple sequential program and turn it into a concurrent program. So I think we'll start by looking at just about the simplest sequential program that it's possible to write. This function here computes the area of a square. There's nothing complicated about it. It's got two clauses, and it's got two patterns. The patterns are square of X, and rectangle of X,Y. And what happens here is if you call the function area with some value like the square of 10, it's going to compute 100. X is going to be bound to 10 and it will return X times X.

0:41Skip to 0 minutes and 41 secondsSo there's nothing complicated about that at all. And we've seen code like that everywhere in sequential code. The central part of that-- two things which I call arrows that consist of patterns followed by actions, and they are separated with an arrow. To the left hand side of the arrow is the pattern. And on the right hand side is the action. To make that into a concurrent program all we need to do is wrap these arrows with the receive statement. OK so what I've done here is I've taken the patterns and arrows and turned them into a receive statement by wrapping them with a receive end statement. You see that on the right hand side of the slide.

1:22Skip to 1 minute and 22 seconds Now in this case how are these patterns-- how do they get into the process? They are the result of sending messages to the process. OK I'll show you that in the next slide. But if you concentrate on this for a moment, on the left hand side you'll see sequential code, area of square, area of rectangle. On the right hand side of the slide you see that turned into process code. What have appeared as patterns on the left hand side of the slide in the sequential code become messages inside the receive statement on the right hand side of the code. The other thing that happens is it's wrapped in a function called area.

1:58Skip to 1 minute and 58 seconds area waits for a message, once it receives a message it pattern matches the two patterns squared of X and rectangle of X,Y against the message it's received. And then it calls itself. OK, so how do we call all that stuff? Well we need to create a process. That's done with a primitive called spawn. And then we need to send messages to the process. And that's done with a primitive called send. Send is written with an exclamation mark. So to activate that process and get it to do something we'll say Pid is spawn(demo1, area, []) and then we'll say Pid, bang, square of 10. Now what's demo1? That's the name of the module where the process is defined.

2:39Skip to 2 minutes and 39 seconds And what I've done on the right hand side of the slide is just make a very simple module. It's called demo1. It exports a function called area with zero arguments. And that has this receive statement that's going to receive a message that's sent to it and do something with that message. So if we say Pid, spawn, demo1, area, then we send it a square message. It receives that message, pattern matches it inside the receive statement and then it computes X times X. It doesn't do anything with the result. So that's actually not a very interesting program. We won't see anything if we run that program.

3:16Skip to 3 minutes and 16 seconds So to make it slightly more interesting we can add a print statement to the program. So if we change that program a little bit having received this message square of X it can print out the value of X squared. Again, not a super exciting program. The first modification we might like to make to that is for that program to send back a result to the program that sent it a message. And that involves a very simple change to the program. I've changed that program now so that it looks like this. We have to add an additional parameter to the message. I've called that From.

3:50Skip to 3 minutes and 50 seconds If you look at the code inside the receive statement, you'll see it consists of a pattern from comma square of X. And from is the identity of the process that sent the message to this process. And of course it has to reply to this process. So it says from, bang, X times X. That means that from the point of view of the demo-- demo2 program-- it receives a message. It doesn't know who it's come from. But it knows the name of the thing. It's asked to compute the area of a square, square of X, and it sends a message back to the process that requested this data.

4:25Skip to 4 minutes and 25 seconds So to call that we need to change what happened in the client process. So again, just as in the last thing, we say spawn, mod, area. In fact mod should be demo2 in this case. Then we send it the message square of X. And then we wait for a reply to come back. And that should contain this value of X squared that we saw in the last message. But there's a bit of a problem with that code. In fact any process that was waiting-- any other process that happened to send a message to the process that sent the square message to the area process would be received by that process. We might get confused.

5:03Skip to 5 minutes and 3 secondsWe might get the wrong message in. So the next modification to this program is to again change it slightly. And if we start at the client side of that and say, OK so let's spawn the process. We'll send it a message. And then we'll wait Pid, bang, self square 10. That sends a message to this process called Pid. And then we wait for a message that can only come back from the process we sent the message to. And that's what this pattern matching does. So I've introduced a few more things there. I've changed the code slightly. And I've introduced this primitive self. Self is the identity of the process itself. And we can pattern match on that and so on.

5:44Skip to 5 minutes and 44 secondsThat's pretty easy. So what I've done is I've shown you four primitives. I've shown you the spawn primitive, that creates the parallel process. Pid, bang, message, that sends a message to a process. And then we have a receive statement where we just took the same kind of patterns and actions as we saw in sequential code and wrapped them inside a receive statement. And there's a self primitive, and that provides our own identity. And with these four things we can build all sorts of complicated things. In the next lecture-- in the next section I'm going to show you how to do that. Right. I've been glossing over some of the details a bit.

6:20Skip to 6 minutes and 20 seconds We don't actually send a message to a process, we send a message to a mailbox. Now each process has a mailbox. You can think of this as just a regular mailbox like you might have outside your apartment. And what happens when you send a message to a process, the message that you sent gets put inside this mailbox. And the receive statement is something that sort of goes and looks in the mailbox, sees if it can match any of the patterns in the receive statement. And it removes that message from the mailbox if it's there. Otherwise it just suspends the process.

6:54Skip to 6 minutes and 54 secondsThe other thing I think I've glossed over a bit is the distinction between concurrency and parallelism. What I'm describing are concurrent activities. That doesn't mean to say that they will be executed in parallel. If we run a concurrent program on a single core computer it will never be executed in parallel. We might think it's being executed in parallel, and that's because the CPU is rapidly interleaving lots of tasks so that you get this kind of illusion of parallelism. It just works for a little bit on one of the processes. And then it stops what it's doing and it picks up the next process. And it does this interleaving so rapidly that you think it's running in parallel.

7:34Skip to 7 minutes and 34 seconds If we had a dual core computer then we can never actually run more than two things in parallel. And again we try to interleave the activities that are going on. So in Erlang what you do is you describe the concurrency that you want. You might say I want 10 parallel-- well 10 concurrent activities. If you happen to have a 10 core computer, all those 10 might run in parallel on the different cores of the computer. Or they might not. But what you have done is describe the concurrency. Concurrency is an abstraction. It is not the same thing as parallelism.

8:04Skip to 8 minutes and 4 seconds What we would hope, of course, is that once we've written a nicely concurrent program and we add more cores that program will just go faster without us having to modify that program. And for a lot of programs that is true. We've been very sort of fortunate in that when multi-cores came along we could take old Erlang code, run it on modern multi-cores. And we didn't actually have to change that code much to make it go faster. It just ran faster because we had described everything as sets of concurrent processes. Right. The next thing is time. I haven't talked about time at all. Time has sort of been outside this model.

8:42Skip to 8 minutes and 42 seconds So what happens if we send a message to a process and it doesn't reply? We want to do something after a certain time. So there's a little change we can add to the receive statement where we add what's called an after construct. We say receive patterns and actions as before. And then we say after a certain time, if that time has elapsed then perform a different set of actions. OK so it's not always easy to decide what to do. That is actually quite complicated, but it does allow us to be able to deal with time in a kind of sensible manner.

9:14Skip to 9 minutes and 14 seconds OK so what we're seeing now is a system where you can send a message to a process if you know its name. So the process which creates the process using the spawn primitive, it knows the name of the process that it's going to send a message to. But no other process in the system knows that name. So we need a way of communicating those names to the different processes in the system. And to do that, there's a global name registry that's built into Erlang. And it's accessed through two primitives, one called register and the other called-- it's called whereis. So we can say, OK, so this process that we've created is going to have this name.

9:56Skip to 9 minutes and 56 seconds So when the system starts it will create a process that, for example, is called Fileserver. And it will register it with the name Fileserver. And processes that want to use the Fileserver could say, where is the Fileserver? And they will get the process identified, and then they can send messages to that process. So that's the kind of analogy of the DNS resolver principle that's used in the internet. We register names with DNS and then a resolver goes and looks up those names. And then once we know where the thing is we can access the service that's involved.

