0:03Skip to 0 minutes and 3 secondsJOE ARMSTRONG: In this lecture, I'm going to talk about how we handle errors in Erlang. The model that Erlang uses for handling errors is very different to the models of error handling that you will see in sequential programming languages. Erlang was designed for writing fault-tolerant systems, so error handling is possibly the thing in Erlang that is strongest. Once you've understood error handling in Erlang, you've understood a lot about why things in Erlang are as they are. If you have a sequential programming language, a sequential language has only one process. So if that one process crashes, you're going to be in deep trouble. So you will take extraordinary pains to make sure that that process doesn't crash. That's called defensive programming.

0:46Skip to 0 minutes and 46 seconds Defensive programming leads to lots of unnecessary code that handles cases which in practice don't occur often. But in Erlang, we don't do it that way. We build things using large numbers of small processes. We're not really so concerned if the individual processes crash. If a process crashes, then somebody else will fix up that error. That's the basic assumption we make. Before I look at what's going on inside Erlang, I just want to talk about the principle of remote error handling, because you don't find this in any other programming language. OK, so imagine you're going to build a fault-tolerant computing system. Well, the first thing to notice is you can't build a fault-tolerant system with only one computer.

1:27Skip to 1 minute and 27 seconds Suppose I've got one computer, like this, and the entire computer crashes. Not a process inside the computer, it's not due to a programming error, it's due to a hardware error. The entire computer crashes. So if this entire computer crashes, you're lost. You can't do fault-tolerant computations, at least not the sort we want to build Erlang systems for, with one computer. You need at least two computers. So if we have two computers and some kind of observation principle, then we can arrange to do simple fault tolerance.

1:59Skip to 1 minute and 59 seconds We make sure that a second computer observes the first computer, and if the first computer crashes, it's detected by the second computer, and we must arrange that the second computer can take over whatever the first computer was going to do. Of course, we can we can do it in a more symmetric sort of way, that we can have pairs of computers that observe each other. So if the first computer crashes, the second computer will observe that error and take corrective action, and if the second computer crashes, then the first computer will take over. We don't really want the mechanisms for takeover and things to differ depending on the number of computers we build in our system.

2:41Skip to 2 minutes and 41 seconds We want it to work if it's a system with one process or thousands of processes. We want the same mechanism to be pervasive. OK, so I'm going to look at what happens when errors occur in processes. So let's start by imagining a system that's got a large number of processes. So these circles, they represent Erlang processes.

3:12Skip to 3 minutes and 12 secondsOK, so here's a system that's got eight processes, and I'm supposing that any one of those processes might crash. So this process might crash or that process might crash. As I've built that system, nothing will happen, no other process in the system will know anything about the fact that the process has died. So if that process dies, it will just die and nobody will know. OK, so what we've added to Erlang is the notion of a link. The link, I'll show a link in red. So this dotted red line, that represents a link between these two processes. That represents a link between those two processes, and so on.

3:55Skip to 3 minutes and 55 seconds So if I name the processes, let's call that process A and that process B, there's a primitive in Erlang, where I can to say link(A,B) and having executed link(A,B) it will create a link between the two processes. Now what's the purpose of a link? The purpose of a link is to define an error propagation path. What it means is that if that process dies, if process A dies, the error will propagate along the links to any process at the other side of the link. So the process that will be informed if A dies is B. If B dies, then A will be informed.

4:38Skip to 4 minutes and 38 seconds And this process here, let's name these processes, call these C and D. OK, so if C dies through any type of error whatsoever, then the processes A and B will be informed. And if B dies, A and C will be informed. If A dies, B will be informed. In Erlang, this propagation of errors works across processor boundaries. So if I draw a big boundary like this round everything, and I assume that's one machine, if I take a second machine like this in the network, and I put a few processes on it, here, X, process Y, process Z, and I link them together like this, OK, so now we've got a system of processes on two physically separated nodes.

5:40Skip to 5 minutes and 40 secondsThis might be in Sweden, that might be in Australia. It doesn't matter where they are, the link mechanism works exactly the same. Once I've linked B and Y together, and Y and Z together, if an error occurs in A, it will be propagated to B. If an error occurs in B, processes A and Y will be notified. If this process has an error, these two processes will be notified. Now, the normal behaviour of a process if it gets one of these error signals is to die itself.

6:12Skip to 6 minutes and 12 seconds OK, so what happens in a system that's been linked together like this, if any of these processes A, B, Y, or Z dies, then all of them will die, they will all be removed. So if that process dies, an error signal is sent to this process, this process will die. An error signal is sent to this process, this process dies. An error signal is sent to that process. And they all die. But we want to stop that from happening. So we can turn things into system processes. A system process essentially sets up a firewall, whereby we can monitor the process of errors.

6:45Skip to 6 minutes and 45 seconds So if I draw a red circle around there, that means that process B becomes a firewall process, and it doesn't die if it receives an error signal. Now, to turn it into a system process, we say process_flag(trap_exit,true) and that means that it's trapping exits. Having said that, then B will not die if the process A or Y dies. What will happen is it will be sent a special form of message, which it can receive in a receive statement. Now, that receive statement is of the form receive{'EXIT',Pid,Why} and this tells you why the process died. So this gives us a hint as to how we're going to build fault-tolerant systems.

7:45Skip to 7 minutes and 45 seconds We build large collections of processes, we link them together, and we make certain ones of them into system processes, which can handle the errors. And that is actually enough to build fault-tolerant systems. We need essentially two primitives, link(A,B), which links two processes together, and process_flag(trap_exit,true), which turns error signals into error messages, which can be received as if they were normal messages. That's pretty much all you need. There are some details. link(A,B) is symmetric. Either A can say link B, or B can say link A, or you can link A and B together. The effect is the same. If A dies, B gets sent a message, and if B dies, A is sent a message.

8:36Skip to 8 minutes and 36 seconds That symmetry is sometimes not very convenient to deal with, and so there's something called a monitor. A monitor is a halfway link. If A says monitor B, then if B dies, A gets a message, but not the other way around. And these can be used in layers to build fault-tolerant systems. This is a large part of the OTP system. This is a graph. There's no structural relationship between the different processes. It just defines the error propagation paths.

9:06Skip to 9 minutes and 6 secondsWhat happens in the OTP system is we build them into trees rather than graphs, and let's just rub out a little bit here, so you can see a tree. What we'll do there is build a tree of processes, something like this, where these layers here, these are called supervisor nodes, their job is to look after their children and only that, and if these die, then the people above them are going to take care of those errors. This kind of architecture has been used to build highly fault-tolerant systems, which have been running for many years without intervention. Nobody knows the longest system. We think there are some systems that have been running for six or seven years, which have never crashed.

9:55Skip to 9 minutes and 55 seconds And they are built from collections of nodes who are programmed to observe each other's faults and then take corrective action. We don't actually take much care to make sure that the individual processes are always alive. We let them crash, and we let other processes detect those errors, and we try to correct those errors.

10:18Skip to 10 minutes and 18 secondsIf you were to make the assumption that we could write programmes in such a way that they will never crash, I don't think we're ever going to be able to do that. We have to live with the fact that processes are going to crash, and then we have to detect that remotely, and then we have to try to correct that. And the reason for this remoteness is based on this argument that if an entire computer crashes, the only way to correct it is in a different computer, and so that is fundamental to Erlang. And it's something that is very strange. It's something that you don't find in any other programming languages.

10:49Skip to 10 minutes and 49 seconds Other programming languages say you should take Trojan efforts to make sure that your programme doesn't crash. In Erlang, the philosophy is, well, OK, so if something unexpected happens, just crash, because we will assume that things are always going to crash. The default assumption is we can never protect against crashing. So let's just assume that things are going to crash. Let's observe the fact that they have crashed, and let some other process have the responsibility of fixing up those crashes.


