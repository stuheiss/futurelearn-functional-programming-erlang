0:05Skip to 0 minutes and 5 secondsErlang has a facility for loading new code into a system that's running without taking the system down. This is called hot code loading, and that's what we're going to talk about in this step. How is code loaded into the virtual machine? We ought to find that out first. Well, when we call a function from a module Foo, we will load the Foo.beam file if it exists.

0:31Skip to 0 minutes and 31 seconds Also, so when we compile a module Foo, or we-- either using c(Foo) in the shell or calling the Erlang compile:file function, module is loaded. And finally, there's a function in the code module, the load_file function that will load the module. So there are various ways of ensuring that code for a module is loaded into the virtual machine. Now, we can also find out what is already loaded. There's the is_loaded function in the code module, this will tell us. It will tell us the path if a file is loaded. So that's useful.

1:09Skip to 1 minute and 9 seconds It tells us not only whether it's loaded, but which version of the beam file, if there are multiple versions, is being used, and that's often useful for diagnostic purposes. It'll return false if it's not loaded. And just if you're interested, you can see-- at any time in the shell, you can see which modules are loaded just by hitting the tab key. And just if you-- if you hit that after you load, after you power up the Erlang shell, you'll see how many modules there are in running the standard runtime system. Interesting to see.

1:42Skip to 1 minute and 42 seconds OK, so at any one time, the system can contain up to two versions of a module, and those are called the old version and the current version. Now, when a new version is loaded, that version becomes the current and the code it replaces becomes the old. So the old current code is the old, the thing we just loaded is the current. And the previous old code is purged, any module that's running that version of the code will be terminated. So at that point, we potentially will have parts of the system failing, and we'll have to use supervision or whatever to deal with that.

2:32Skip to 2 minutes and 32 seconds But we ensure that there are only two versions of any module running by purging versions that are running old code. So be aware of that. Now, the $64,000 question is, when does the new code get used? So here we've got a picture of the old and the current code. Suppose that we've got the purple module is using the current code. We load some new code. The client module still uses the code it was running until there's a call in that module any function in Foo. And at that point, when that function call is executed, the module starts using the new version of Foo for every possible function.

3:27Skip to 3 minutes and 27 seconds All the functions in Foo, it switches over to use the new version like so. So there we see it carries on using the version it was using until it reaches a function call.

3:46Skip to 3 minutes and 46 secondsNow, what happens to the module itself? Suppose it calls itself recursively. Suppose that the purple module is actually the current version of Foo and we load a new version of Foo. Well, when there is a fully qualified call to a function in Foo, it switches. But if there are only non-qualified calls, the switch is not triggered. So if, for example, you want to write a loop where you expect to update the body of the loop, you need to make sure the recursive call to the loop is a fully qualified call.

4:32Skip to 4 minutes and 32 seconds So there is that degree of control, and so there's semantic information in deciding if you're in the module Foo, whether you call functions as Foo colon something, or just something. It doesn't change the behaviour immediately, but it can change the behaviour on code loading.

4:57Skip to 4 minutes and 57 secondsThen what happens to modules using the old code? What happens is that they'll carry on using the old code, and that code is terminated, the code is purged, and the module will be terminated. So if you're using the old code, that module will be terminated. And so as I said earlier on, you need some mechanism for dealing with that, potentially using supervision. If you want to restart the module, it will restart using a different version of the code. Now finally, it's possible manually to remove old versions as well.

5:39Skip to 5 minutes and 39 secondsYou can call code:purge, or code:soft_purge. If you call soft_purge, it removes an old version of the code that isn't being used. So it checks that it's no longer being used and effects that change. Purge will always succeed, but it may cause things to fail. I just conclude by asking you the question, why might we want to purge the old version? So just to summarise, what we've seen here is a high-level introduction to Erlang's hot code loading. And this is integral to its being a foundation for robust systems. We're able potentially to identify a bug and load a bug fix into a running system without taking the system down.

6:35Skip to 6 minutes and 35 seconds Now of course, you need to make sure the bug fix has not broken anything else. So there are a number of tests, you'll probably be running a test version of the system and try loading the new code into that before you load it into a live system. But it does mean that you can keep a live system running without taking it down. And that's one of the things-- that's key to giving Erlang what's called six nines reliability. 99.9999% availability. OK, so that rounds up this step, which is talking about hot code loading. And what we're going to do now is summarise what we've done in this week in using Erlang to build robust systems.
